# Hermes

## What does it do?

This helps simplify the creation and standardisation of HTML emails.

1. Provides simplified markup for emails
2. Predefined email templates and product branding/color coding.
3. Variables for common links
4. Builds HTML and TXT email templates, ready for upload
5. Inlines CSS

This is a much faster way to produce emails that are easier to read and easier to edit.

## Installation & Geeky stuff

This uses grunt, assemble and handlebars to compile email ready HTML, the main difference between this version and the original is it has been modified to use Zurb's Ink framework.

### Requirements

* **Node.js** - [Install Node.js](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)
* **Grunt-cli and Grunt** (`npm install grunt-cli -g`)
* **Ruby** - [Install ruby with RVM](https://rvm.io/rvm/install)
* **Premailer** (`gem install premailer hpricot nokogiri`) - Required for inlining the CSS

### Instructions

1. **Ensure Ruby is installed on host machine.** *MacOS has ruby installed by default*
2. **Download and install [Node.js](https://nodejs.org)**
3. **Install Grunt, then grunt-cli and premailer**
4. **You may also need to install the sass gem**
5. **Choose a location for the script**
6. **Install node components**  *This is a really easy step to miss*

	`cd script-folder-location 
	npm install`
	
7. **See if it works**

	`cd script-folder-location grunt`
	
	You should get some pretty good feedback in the terminal to see what needs fixing.
	
## Ink framework

Ink is a responsive email framework, used to make HTML emails look great on any client or device. It includes a 12-column grid, as well as some simple UI elements.

Ink requires quite strict markup in order to work across so many email clients.

[Full Ink Documentation](http://zurb.com/ink/docs.php)

Luckily there are a lot of shortcuts in here to make the creation of these emails faster. Woohoo!
	
## Using the script

### Folders

There are a bunch of folders inside the script, but you old have to worry about two **dist** and **src**

* **dist** contains your email output. The final emails ready to be uploaded to eloqua
* **src** contains a bunch of folders, but again, theres only a few you need to worry about **data**, **emails** and **partials**
	* **data** contains all of the variables you can use to link to common things or output common text.
	* **partials** contains all of the preset ink partials, you can also add your own. (More on this later)
	* **emails** This is the most important folder, and the one you'll spend all of your time in, it contains all of the source emails that you will be creating.

### Creating your first email

Inside the src/emails folder you'll see an example file, take a look, it'll give you a lot of hints on how to get things done. This is a working email and you can play with it and break it, whatever really. It's all well and good, but you're here to make your own. So here's how you do it.

#### Create a new email.hbs file

Inside src/emails, create a new file (You can do this from your text editor) and call it *something***.hbs** or whatever you want your email to be called. The .hbs extension is very important. The system outputs HTML, but we write it in a special templating language called handlebars (Don't worry, its easy)

#### Add the boilerplate

At the top of example.hbs you'll see 4 lines that look like this

```
---
layout: default.hbs
published: true
subject: test
color: default
---
```

Think of this as the configuration section of your email, let's go through what they do:

* **layout** this is the overall frame of the email, at the moment there is just the one. This determines the type of email you are sending, marketing emails will almost always be 'Default', this just sets up the headers and footers of the email, along with unsubscribe and social media links.
* **published** if you set this to false, this template will not be generated by grunt.
* **subject** this is the subject line of the email (obvs).
* **color** defines the colour code and branding for the email, headings and buttons etc. Snazzy.

When you create a new email file, make sure these three lines are at the top.

#### Handlebars

Don't be scared! It's not scary! Handlebars gives use lots of funky things we can do with templating, making lots of things easier to write and easier to read. Also there's a lot less code on screen. This is all output to regular HTML and we can mix in regular HTML wherever we like in the template.

Handlebars markup is anything inside double curly braces `{{ I am some handlebars }}` it's called handlebars because if you turn your head to the side, a curly brace looks a bit like a handlebar mustache. 

##### What can I do with handlebars?

Handlebars is used for outputting variables and partials in your email. If you're writing a heading, paragraph etc, you can just use regular HTML.

### variables

There are a bunch of preset variables to use inside your email templates, so you don't have to copy and paste a lot of the same links or text. Take a look at the file inside the **default.hbs** file inside **data** folder and you can see whats available, you can even extend this with lots more variables, but more on that in a sec.

#### Adding a variable

Just type `{{default.variableName}}` the `default` part let's handlebars know where the list is, the second part is the name of the variable. It's that simple.

#### Creating new variables

If you find yourself typing a lot of the same things over and over again, you can save yourself some time and add it to the list of variables, which is dead easy. Just go to the **default.hbs** file inside **data** folder, add a new line and type something like:

`somethingAwesome: "Peanut butter sandwiches"`

And that's it! Save the file and you're off! 

The first part is the variable name that you'll call it with, the second part between the quotes is the content of the variable. 

**Note:** Variable names cannot contain spaces or weird characters like ! or â‚¬, but you can use dashes and underscores, the most readable and shortest way to write variable names is [camelCasing](http://searchsoa.techtarget.com/definition/CamelCase)

#### Header variables

Inside /data is a file called header.yml that contains links to a whole load of predefined email headers for products, you can also add more :) Yake a look.

### Writing your email

You can now just write your email as normal, using the partials provided. Which I'll cover in the next section.

### Now what?

So you have your **email.hbs** file, but how do you turn this into a real email? Ok, again, don't get scared, this is really easy. You'll need to use the **terminal** which is a command line bit of software on your computer. It's not as scary as it seems, also you look like a badass hacker when you use it. Chicks dig hackers.

1. Open the terminal - this is in the utilities folder in applications on Mac os, or just use spotlight to open it.

2. If see a line that says something like `ash$` we're in! The terminal opens you up in a text view of the **home folder** of your computer
3. We have to learn just two commands to make this work, **ls** and **cd**
	* **ls** means list, give it a go, just type `ls` and hit enter, it'll give you a list of all the folders in your home directory, sweet.
	* **cd** means 'change directory', so say if your script is on your Desktop, you can just start typing `cd Desktop/email-build` and then press enter. You are now inside that directory. Try `ls` again and you'll see all of the folders inside. Boom.

Ok, I lied, theres just *one* more thing to do. Once we are inside this folder we need to run one more command that will make all of the magic happen. Once you are inside your **email-build** folder, you just need to type the word 'grunt' and press enter. It'll start churning through all of the emails in the **src/emails** folder and spit them out into the **dist** folder. Wizard. If anything goes wrong, the terminal will tell you.

And you're done!


No, seriously, you are. You can now just copy the email.html file from **dist** to eloqua. The script will process all email files inside **src/emails** and spit them all out at once. If you make a change to an email template, just run `grunt` again and it'll generate them all again.

### Tips

* The more emails you have, the longer it'll take grunt to generate them all. So if you are done with a particular template, just move it out of the folder and grunt will run quicker.
* Dist will probably get messy after a while, so don't be afraid to remove it's contents. If the .hbs file still exists, you can just re-generate it any time you want.


## Templating
Before you start, it's **highly** recommended you read Ink's [Documentation](http://zurb.com/ink/docs.php) to fully understand how it works.

Although I've tried to make it as easy as possible to write templates there are still some important steps to go through and things to know about Ink that you need to bear in mind when writing emails. Don't worry too much, it's not hard and it's still a lot easier to write emails than before :)

### Partials
Think of partials like blocks (If you're familiar with Concrete5) they are effectively chunks of predefined code that you can pass parameters (options) to. They are like shortcuts, making complicated email markup easy to read, or making repetitive tasks faster. 

We have a lot of predefined partials to use and it forms the basis of templating with this system. You can also make your own! But more on this later.

#### How to use a partial

Partials have a very specific syntax (Way of writing) that must be followed. A partial looks like this:

`{{>partialName  parameter="value"}}`

They are contained in `{{>` & `}}`

The first thing you should write is the partial name, which tells handlebars which partial you are using, the list of ink partials is further down this document.

The second part is where you add 'parameters', think of these as options that get passed to the partial and make it do something, these are preset and vary by partial, but you can see the list of accepted parameters by partial below. Partials can accept multiple parameters.

#### Types of partial
There are two types of partial in this system, **containers** and **self-closing** partials

##### Containers

Container partials have two parts, an opening partial and a closing partial. All of your text and images should be in-between these. A container partial looks like this:

```
{{>box  columns="twelve" pad="left"}}

	<h1> Hello!</h1>
	
{{>box-ends}}
```
The closing partial always has the same name as the opening partial with **-ends** at the end.

You can add any HTML markup you like in between the opening and closing partials, but you should **not** add anything that will modify the layout of the email. Just content. All layout **must** be created with partials.

##### Self-closing partials

Self-closing partials are similar to Container partials, but with one key difference, yup, you guessed it, you don't have to close them. You simply add the partial, pass in some parameters and you're done! Two examples of Self-closing partials are buttons and images. Which look like this:

`{{>image src="image.jpg"}}`

`{{>button link="http://google.com" description="Link to google"}}`
___

### Element structure

Ink follows a very strict structure of markup to ensure emails are deliverable. See the Grid section of Ink's documentation for more in-depth details.

The structure always goes:

**row** > **wrapper** > **column**
___

#### Rows

Ink emails are based on **rows** think of a row like a block, it's a full strip across an email. **EVERYTHING** is in a row.

#### Wrappers

Around a **column** there is a **wrapper**, columns will not work without a wrapper. Luckily the **column** partial already contains a wrapper. So why am I mentioning it? 

The last wrapper in a **Row** ALWAYS needs the *end* parameter, otherwise your layout will break.

But generally you don't *need* to add wrappers yourself. Although you can. If you want. Weirdo.

#### Columns

Columns denote the width of the content, as based on a 12-column system. The content inside them will expand to cover n-columns, assuming that the number of columns in one row adds up to 12.

A row needs a column, even if it's just one. The column partial has a *columns* parameter, where you specify the number of columns. Remaining columns in rows stack horizontally unless the number goes above 12. You do not have to manually set any widths. So if you have a row with two columns, it would look like this:

```
{{>column columns="six"}}
	I'm with stupid-->
{{>column-ends}}

{{>columns columns="six" end="true"}}
	<-- He's the stupid one.
{{>column-ends}}

```
 
**Remember:** The last column in a row needs to have the *end* parameter. So the entire row would look like:

```
{{>row}}

	{{>column columns="six"}}
		I'm with stupid-->
	{{>column-ends}}

	{{>columns columns="six" end="true"}}
		<-- He's the stupid one.
	{{>column-ends}}
	
{{>row-ends}}

```
This row is valid and will work lovely-ly.




### List of predefined ink partials
All partials contain a parameter called *classes* for any extra styling and some little layout flourishes, but more on this later. Some partials have **required** parameters, they will not work correctly without adding these parameters. Some partials will also have a list of predefined classes, to use a predefined class, add a classes parameter then add the desired predefined class to your partial.

### header - *Self-closing*
`{{>row}}` contains a table with a **row** class.

**Optional parameters:**

* ***classes*** 
* ***product*** - Accepts a product name for a generic header


### row - *Container*

`{{>row}}` contains a table with a **row** class.

**Optional parameters:**

* ***classes*** 

**Predefined Classes:**

**Colours**

* ***intro*** - adds a background colour to the row
* ***intro-light*** - adds a background colour to the top of the email
* ***intro-colored*** - adds a background colour to the top of the email

---

### box - *Container*

`{{>box}}` is a shortcut for creating a full-width row with no extra markup. Nifty. **Note:** Box cannot contain columns, but can contain subGrid partials. 

**Optional parameters:**

* ***columns*** - set to 12. You can set it to something else, but will not accept a second column, so the row would be empty beyond that point. 
* ***classes***
* * ***pad*** - accepts: `"left"`,`"right"`or`"both"` defaults to both if no value set.

---


### column - *Container*

`{{>column}}` contains a **column** and an opening **wrapper** columns should always be inside a row and the column number should always equal 12. The *columns* parameter value can be written in text or numbers. **Important:** The *end* parameter is should always be used on the **last** column in a row.

**Parameters:**

* ***end*** accepts: `"1"` or `"true"` this sets the class for the last wrapper in a row. Defaults to false.

* ***columns*** or ***col*** - accepts: `"one"`,`"two"`,`"three"` etc, all the way to `"twelve"` or  `"1"`,`"2"`,`"3"` all the way to `"12"` - defaults to 12 if no value set. *col* is just a shortcut, column should not have both.

**Optional parameters:**

* ***col-classes*** additional classes for the `{{>column}}` element
* ***classes*** additional classes for the contents`{{>column}}` element
* ***Offset*** or ***move*** - accepts: `"one"`,`"two"`,`"three"` etc, all the way to `"twelve"` or  `"1"`,`"2"`,`"3"` all the way to `"12"` - offsets a column by a number columns, should still equal 12.
* ***pad*** - accepts: `"left"`,`"right"`or`"both"` defaults to both if no value set.

---

### button - *Self-closing*

`{{>button}}` is a bullet proof way of creating a button, buttons stack vertically, if you need two in line you need to start working with **subGrid**

**Required parameters:**

* ***link*** - accepts a URL **Required**
* ***description*** or ***desc*** - accepts a string, the words on the button. *desc* is just a shorter way to write a description, a button should only have one of these parameters, **not** both.  **Required**

**Optional parameters:**

* ***width*** - accepts either ```"half"``` or ```"quarter"```, by default a button fills the width of the container it sits in, this overrides that width and sets it to either one half or a quarter of the width of it's container, buttons revert to full width when viewed on mobile.
* ***classes***

**Predefined Classes:**

**Colours**

*  ***button-2*** - Alternative default button color, lighter grey.
* ***colored*** - Colours a button to match the colour theme of the selected product
* ***colored-two*** - Colours a button to match the colour theme of the selected product
*  ***colored-three*** - Colours a button to match the colour theme of the selected product

**Sizes**

*  ***tiny*** - Affects button size
*  ***small*** - Affects button size
*  ***medium*** - Affects button size
*  ***large*** - Affects button size

---

### image - *Self-closing*

`{{>image}}` is for creating retina ready images for mobile, you don't *need* to use it, but it is a very handy way to use images, `{{>image}}` should always be in a column. It will inherit the padding from that column

**Required parameters:**

* ***src*** - accepts a URL for image source


**Optional parameters:**

* ***classes***
* ***link*** - accepts a URL for link
* ***alt*** - accepts alt text for the image
* ***size*** - should be set to the size of the containing column accepts: `"1'`,`"2"`,`"3"` etc, all the way to `"12"`

---

### link - *Self-closing*

`{{>link}}` is for text based links, it's just shorthand for ```<a href="#">A link</a>``` if no colour is set, the link will be the standard link colour.

**Required parameters:**

* ***link*** - accepts a URL for link **Required**
* ***desc*** or ***description*** - the text for the link. **Required**

**Optional parameters:**

* ***classes***
* ***color*** or ***colour*** - Sets an optional color for the link text, this should be a hex value, e.g - #123456

---

### subGrid - *Container*

`{{>subGrid}}` is for horizontally stacking elements inside a column. Think columns inside columns. subGrid works largely the same way as column but can only be used *inside* a column. subGrid's do not have a wrapper element, but **do** require the *end* parameter in the same way as column. Make sense?

**Required parameters:**

* ***end*** accepts: `"1"` or `"true"` this sets the class for the last wrapper in a row. Defaults to false.
* ***columns*** or ***col*** - accepts: `"one"`,`"two"`,`"three"` etc, all the way to `"twelve"` or  `"1"`,`"2"`,`"3"` all the way to `"12"` - defaults to 12 if no value set. *col* is just a shortcut, column should not have both.

**Optional parameters:**

* ***classes***

---

### blockGrid - *Container*

`{{>blockGrid}}` For cases where neither the grid nor  subGrid is appropriate, blockGrid can often be quite useful. BlockGrid elements automatically align to the left and are pushed down to the next row individually as the viewport gets smaller, read the Ink docs for more detail. blockGrid has **three** parts.

blockGrid does not work the same way as regular columns, and should mostly not be used, blockGrid should be structured like this:

```
{{>blockGrid size="3"}}
      First Block
      {{>blockDivider}}
      Second Block
      {{>blockDivider}}
      Third Block
{{>blockGrid-ends}}
```

* A divider is required between each block (not the last)
* Do not leave blocks empty.

**Required parameters:**

* ***size*** - accepts: `"one"`,`"two"`,`"three"` etc, all the way to `"twelve"` or  `"1"`,`"2"`,`"3"` all the way to `"12"` size is required.

**Optional parameters:**

* ***classes***

---

### blockDivider - *self-closing*

`{{>blockDivider}}` is used to separate entries inside a block grid. It is the only partial with no parameters

---


### List of Eloqua predefined partials

### dynamic - *self-closing*

`{{>dynamic}}` inserts an eloqua dynamic field into your email body. You still need to first create the dynamic content in eloqua, this just points to that content.

**Required parameters:**

* ***id*** - this is the eloqua dynamic field ID

---

### merge - *self-closing*

`{{>merge}}` inserts an eloqua merge field for firstname and the like. The list of current fields is in partials/eloqua/eloqua helpers/mergeFields.hbs

**Required parameters:**

* ***type*** - this is the name of the field you wish to add, check the list to see what's available.


### Creating your own partials

So these are awesome and form the basis of the system. But you can also create your own, to help speed up your working day. Bonzer.

All you need to do is go to **src/partials** folder and add a new file, call it **stuff.hbs** or whatever you want your partial to be called. Unlike a variable, which can only contain text strings, a partial can contain literally anything you like. You could have an entire chunk of code or whatever you like, you can even put partials **inside** partials (Although it might destroy the universe if you do it too many times) 

So once you're done, just save the file and you're off. To use your new partial, just type `{{>whateverYourPartialIsCalled}}` inside an email template and it'll add the code for you.

You can also pass your own parameters into your partials. But come ask me if you want to know how :)

## Previewing changes

If ```grunt``` takes a while to run, you can preview your changes by typing ```grunt serve``` in the terminal. This will build your templates once, then watches the complied files for changes, which then update in the browser. Wizard.

When you're done previewing changes, you'll need to rebuild your templates, grunt serve is a process, which means it keeps running and you need to stop it in the terminal to type a new command, you do this by pressing **ctrl (Not command) + C** in terminal.

For a quick preview without live updating, run ```grunt preview``` this will compile your templates in less than half the time. **Remember**: before you upload you will need to run regular ``grunt`` again, as preview complied files are **not** deliverable.